## Как компилировать стороннее ПО из исходного кода

Компилировать и настраивать программное обеспечение в ручном режиме — это самый трудоемкий и долгий способ устанавливать программы в системе. Однако, несмотря на все сложности, это традиционно самый надежный способ установить ПО, не прибегая ни к каким сторонним зависимостям помимо стандартных инструментов программирования (компилятор, компоновщик и makeфайл).

Вся процедура состоит из нескольких этапов и может незначительно различаться в зависимости от того, что и куда вы устанавливаете. Обычные этапы таковы:

1. С помощью curl или wget загрузить сжатый архив с исходным кодом ПО.
2. Запустить tar zxf файл_архива или unzip файл_архива, чтобы разархивировать и распаковать каталог с исходным кодом, который вы только что загрузили.
3. Перейти в каталог с исходным кодом и прочесть в нем все файлы README. Обычно там указано, как конкретно установить это программное обеспечение, а также чем установка отличается от стандартной процедуры, которую мы здесь описываем.
4. Чтобы собрать и установить двоичный код программы, запустить ./configure, затем make, а затем sudo make install.




### Предварительные условия для установки

Прежде всего нужно установить набор основных инструментов для разработки на C: компилятор, компоновщик, make и другие средства, которые нужны, чтобы компилировать код на C в системе Linux. В Ubuntu для этого можно установить метапакет build-essential.

```ruby
mkdir /tmp/htopbuild && cd /tmp/htopbuild
sudo apt install build-essential

sudo dpkg -l | grep build-essential
sudo apt list | grep build-essential

# Установим также другие инструменты, которые нам понадобятся: wget3 — чтобы загружать файлы из интернета,
# и библиотеку разработки ncurses, которая нужна программе htop для интерактивного интерфейса командной строки:

sudo apt install wget libncurses-dev
sudo apt install libncursesw5-dev autotools-dev autoconf automake build-essential
```




### Загружаем, проверяем и распаковываем исходный код

На этом этапе мы первым делом загрузим исходный код и проверим его криптографическую подпись, чтобы убедиться, что это подлинный выпуск, который удостоверен ключом разработчика:

```ruby
wget https://github.com/htop-dev/htop/releases/download/3.3.0/htop-3.3.0.tar.xz
```

Давайте теперь убедимся, что это авторизованный выпуск: для этого мы проверим подпись, которая представляет собой просто хеш-сумму исходного кода в формате SHA-256. Загрузим файл, который содержит хеш-сумму для этого выпуска, и выведем его в терминал:

```ruby
wget https://github.com/htop-dev/htop/releases/download/3.3.0/htop3.3.0.tar.xz.sha256
cat htop-3.3.0.tar.xz.sha256 -> 904f7d4580fc11cffc7e0f06895a4789e0c1c054435752c151e812fead9f6220  htop-3.4.1.tar.xz

Теперь с помощью sha256sum захешируем исходный код, который мы загрузили до этого, чтобы убедиться, что хеш-суммы совпадают:
sha256sum htop-3.4.1.tar.xz -> 904f7d4580fc11cffc7e0f06895a4789e0c1c054435752c151e812fead9f6220  htop-3.4.1.tar.xz

Великолепно! Вот мы и убедились, что архив, который у нас есть, совпадает с официальным выпуском, который мы хотели загрузить.

tar -xf htop-3.4.1.tar.xz
cd htop-3.4.1
```



### Конфигурируем и компилируем htop

Теперь пора запустить сценарий ./configure из каталога с исходным кодом. Этот сценарий проверяет, доступны ли все зависимости, которые нужны для компиляции (общие библиотеки, инструментарий и т. д.), и настраивает конфигурацию для того, чтобы скомпилировать программу:

```ruby
./configure
```

Вывод этой команды состоит из большого количества строк, которые сообщают о том, обеспечены ли все зависимости и готова ли ваша среда для компиляции.

```ruby
make
```

Команда `make` не создает один единственный файл. Ее результат — это целый набор скомпилированных файлов и, главное, итоговый исполняемый файл (или библиотеки).

### Что делает команда make?

- **Читает инструкции:** Она обращается к файлу с названием `Makefile`, который был создан утилитой `./configure`. Этот файл содержит "рецепт" — подробные инструкции о том, как собрать вашу программу.
- **Запускает компилятор:** Основываясь на инструкциях в Makefile, make запускает компилятор (например, gcc для C или g++ для C++). Компилятор берет ваши исходные файлы (обычно с расширением .c, .cpp и т.д.) и преобразует их в машинный код — объектные файлы (с расширением .o на Linux/macOS или .obj на Windows).
- **Запускает компоновщик (линковщик):** После компиляции всех исходных файлов в объектные, make запускает компоновщик. Он берет все эти объектные файлы и связывает их друг с другом, а также с внешними библиотеками (например, для работы с графикой, сетью и т.д.), на которые ссылалась программа. Результатом этого шага и является итоговый исполняемый файл.

### Какой будет итоговый результат?

Главным результатом успешного выполнения `make` является создание исполняемого файла. Его имя зависит от проекта. Для известных проектов: имя часто соответствует названию программы (например, vim, git, python). В общем случае: имя исполняемого файла по умолчанию часто бывает a.out, но в большинстве проектов это меняется на что-то осмысленное.

**Где его искать?** Обычно итоговый файл создается в той же директории, где вы запускали `make`, или в поддиректории (часто `src/`, `bin/` или `build/`).

### Краткий пример процесса

Представьте, что у вас есть проект, состоящий из двух файлов: `main.c` и `helper.c`.

- `./configure` — проверяет систему и создает Makefile.
- `make` — выполняет примерно следующее (как если бы вы делали это вручную):

```ruby
gcc -c main.c -o main.o (компиляция в объектный файл)
gcc -c helper.c -o helper.o (компиляция в объектный файл)
gcc main.o helper.o -o my_program (компоновка объектных файлов в исполняемый)
```

**Результат в папке:** Появятся файлы main.o, helper.o и, самое главное, — `my_program`. Чтобы запустить программу, вы бы ввели `./my_program`.

### Что дальше?

После успешного выполнения `make` обычно следует команда:

```ruby
sudo make install
```

Эта команда скопирует итоговый исполняемый файл, библиотеки и заголовочные файлы в системные директории (например, `/usr/local/bin/`), чтобы программа стала доступна для запуска из любой точки системы.

**Итог:** Команда `make` управляет процессом компиляции и линковки, результатом которого является готовое к запуску приложение (и множество промежуточных файлов).

После того как компиляция закончится, в текущем каталоге появится двоичный файл, который называется `htop`. Его можно установить в систему; как правило, это делается автоматически:

```ruby
sudo make install
```

<img width="1807" height="385" alt="image" src="https://github.com/user-attachments/assets/ef665f9f-8249-4d33-9814-9ff7d48ad5dc" />

<img width="1823" height="510" alt="image" src="https://github.com/user-attachments/assets/209741f6-831b-4d4e-b9ca-f02daab8b44a" />

Если все в порядке, то вы увидите живописный текстовый интерфейс, который использует библиотеку ncurses и отображает состояние вашей системы: текущую нагрузку на центральный процессор, потребление памяти и список процессов.

Если полноценная команда `install` не поставляется с программным обеспечением, вы всегда можете полагаться на то, что в Linux нет никакой магии, поэтому двоичный файл можно установить вручную, переместив его в каталог `/usr/local/bin`, где хранятся откомпилированные двоичные файлы:

```ruby
mv htop /usr/local/bin/
```

