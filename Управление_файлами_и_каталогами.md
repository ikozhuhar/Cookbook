## Управление файлами и  каталогами


<br>

_**Задача**: Создание файлов и каталогов._

```ruby
# Cоздаст новый подкаталог в текущем каталоге
 mkdir -v presentations
 
 # Создать двухуровневое дерево каталогов
 mkdir -p presentations/2020/august

# Одновременно с созданием каталога можно задать разрешения
mkdir -m 0700 /home/duchess/dog-memes
```

Посмотореть дерево каталогов

```ruby
# Посмтореть дерево каталогов
tree -L 1 /
tree -L 2 /home
```

Создание файлов

```ruby
# Следующая команда создаст один пустой файл
touch newfile.txt

# А так можно создать 100 новых пустых файлов
touch file{00..99}
touch test{00..99}.doc

# Cоздать непустой файл размером 500 Мбайт, заполненный повторяющейся строкой This is a test file с помощью команды yes
yes This is a test file | head -c 500 MB > testfile.txt

# Cоздание 100 файлов, каждый размером 1 Мбайт
$ for x in {01..100};
> do yes This is a test file | head -c 1MB > $x-testfile.txt;
> done
```


<br>

_**Задача**: Удаление файлов и каталогов._

```ruby
# Удаление единственного файла с подробным отчетом
rm -v aria.ogg

# Флаг -i потребует подтвердить решение перед удалением
rm -iv intermezzo.wav

# Флаг -r (recursive — «рекурсивно»), чтобы удалить каталог и все файлы
# и каталоги, содержащиеся в нем
rm -rvi rehearsals

# Удалить все файлы с определенным расширением
rm -v *.txt

# Удалить все файлы с определенной последовательности символов
rm -v aria*

# Если rm отказывается удалить файл или каталог и вы уверены, что хотите его
# удалить, то добавьте параметр -f (force — «принудительно»).
```


<br>

_**Задача**: Копирование, перемещение и переименование файлов и каталогов._

```ruby
# Копирования двух файлов из текущего рабочего каталога в каталог ~/songs2:
cp -v aria.ogg solo.flac ~/songs2/


# Копирование каталога со всем содержимым
cp -rv ~/music/songs2 /shared/archives

# Этот рекурсивный пример просто скопирует каталог songs2 с файлами. Если
# добавить параметр --parents, то команда сохранит структуру родительских
# каталогов.
cp -rv --parents duchess/music/songs2/ shows/

`-a, --archive` — сохраняет все атрибуты файлов, такие как разрешения, владение и отметки времени;
`-i, --interactive` — запрашивает подтверждение, если копирование приведет к затиранию существующих файлов;
`-u, --update` — затирает существующие файлы, только если копируемый файл более новый. Этот параметр поможет сэкономить время, когда требуется повторно скопировать пакет файлов, часть из которых неизменилась (rsync справляется с этой задачей эффективнее, копируя только изменения).
```

Команда `mv` перемещает и переименовывает файлы

```ruby
# Перемещения двух файлов в другой каталог
mv -v aria.ogg solo.flac ~/songs2/

# А эта команда переместит каталог в другой каталог
mv -v ~/songs2/ ~/music/

`-i, --interactive` — запрашивает подтверждение, если перемещение приведет к затиранию существующих файлов;
`-n, --no-clobber` — предотвращает затирание существующих файлов;
`-u, --update` — перемещает файлы, только если они более новые, чем файлы в каталоге назначения, или если они перемещаются впервые.
```

_**Задача**: Настройка разрешений с помощью chmod._

```ruby
# разрешения для файлов
chmod -v 0600 file.txt
chmod -v 444 file1 file2 file3
chmod -v 644 *.txt
chmod -v 644 abcd*

# чтение/запись владельцу и только чтения группе и всем остальным
chmod -v 0644 file.txt

# права на чтение и запись владельцу и группе, и запрет на все всем остальным
chmod 0660 file.txt

chmod 0750 backup.sh

# все файлы в текущем каталоге
find /home -type f -exec chmod -v 660 {} \;
find /home -user madmax -exec chmod -v 660 {} \;
find /home -user 1007 -exec chmod -v 660 {} \;
```
_Точка (`find .`) сообщает команде `find`, что она должна начать поиск с текущего каталога. При необходимости поиск можно начать с любого каталога._

_`-type f` требует выполнять поиск только среди файлов._

_`-user` проверяет принадлежность файлов указанному пользователю._

_`-exec chmod -v 660 {} \;` — это чудесное маленькое заклинание, которое берет результаты поиска и применяет к ним команду `chmod -v 660`. В этом месте можно использовать практически любую команду, какую вы решите применить к результатам поиска._


Настройка разрешений для каталогов

```ruby
# Следующая команда создаст каталог shared
sudo mkdir /shared

Чтение/запись владельцу /shared и только чтение всем остальным
chmod 0755 /shared

# Владелец имеет неограниченные права доступа к каталогу. Группа и все остальные (мир) смогут входить 
# в каталог и читать файлы, но не смогут их редактировать или добавлять.
chmod 0755 /shared

# Следующая команда применит одни и те же разрешения к существующему содержимому 
# каталога благодаря параметру -R (recursive — «рекурсивно»):
chmod -R 0755 /shared
```

Особые режимы для особых случаев использования

Задействуйте особые режимы `sticky bit`, `setuid` и `setgid`. Режим `sticky bit` применяется к каталогам с файлами, принадлежащими разным пользователям, чтобы не позволить пользователям перемещать, переименовывать или удалять файлы, которыми они не владеют.

Режим `sticky bit` (бит закрепления, или «липкий» бит) имеет описательное название: **бит ограничения возможности удаления**. Этот бит запрещает непривилегированным пользователям удалять или переименовывать файл в каталоге, если он не принадлежит им, например, в каталоге `/tmp`.

```ruby
# sticky bit - t, sTicky «липучка», атрибут ограниченного удаления
chmod -v 1770 /home/duchess/shared
chmod o+t /shared/stickydir
```
![image](https://github.com/user-attachments/assets/10246e5d-9b86-4afd-b76d-180844d3c6ea)


Режим `setuid` применяется к выполняемым файлам, чтобы повысить привилегии пользователя, запускающего этот файл, до уровня привилегий владельца файла:

```ruby
# setuid - s, Set user/group ID атрибут неявного делегирования полномочий
chmod 4750 backup-script
chmod -v u+s backup-script
```

Режим `setgid` применяется к каталогам и выполняемым файлам: все вновь создаваемые файлы в каталоге будут принадлежать к той же группе, что и сам он. Это отличный прием, позволяющий определить верные уровни владения файлами в общем каталоге:

```ruby
# setgid - s, Set user/group ID атрибут неявного делегирования полномочий
chmod 2770 /home/duchess/shared
chmod -v g+s /shared
```

Режим `setgid` также может применяться к выполняемым файлам, чтобы изменить эффективную группу на группу, владеющую файлом.

Удаление особых режимов разрешений для файла или каталога.

```ruby
# Удаление особых режимов несколько отличается от их установки, поскольку при этом требуется использовать
# дополнительный ведущий ноль, как в следующем примере:

# Ведущий ноль для удаление особых режимов
$ chmod -v 00770 backup.sh

# Ведущий ноль можно заменить знаком равенства:
$ chmod -v =770 backup.sh
```

```ruby
# Linux книга рецептов. Карла Шрёдер, стр. 188
# Внутренее устройство Linux. Дмитрий Кетов, стр. 95
```


<br>

_**Задача**: chown - сменить владельца файла или каталога._

```ruby
# Сменить владельца и группы
sudo chown -v madmax:madmax song.wav

# Смена только владельца
sudo chown -v madmax: song.wav

# Смена только группы
sudo chown -v :madmax song.wav

# Сменить владельца и группы для нескольких файлов
sudo chown -v madmax:share file1 file2 file3

# Смена владельца/группы для файлов с опр расширением
sudo chown -v madmax:share *.txt

# Смена владельца для ВСЕХ файлов в каталоге
sudo find / -user duchess -exec chown -v stash {} \;
sudo find / -user 1001 -exec chown -v 1005 {} \;
```










