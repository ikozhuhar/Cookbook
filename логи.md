:white_check_mark: _**Задача:** <a name='1'>dmesg</a>._

Что это? Утилита для вывода буфера сообщений ядра (kernel ring buffer) в реальном времени.

Источник данных: Читает напрямую из буфера в памяти ядра (/dev/kmsg или через системный вызов syslog).

**Особенности:**

- Показывает сообщения с момента последней загрузки системы.
- Буфер имеет ограниченный размер. При переполнении старые сообщения теряются.
- Самый быстрый способ увидеть самые свежие сообщения ядра.
- Не требует прав root для просмотра (обычно).

**Использование:** `dmesg -T` (с человеко-читаемыми временными метками), `dmesg | grep -i error`




:white_check_mark: _**Задача:** <a name='1'>journalctl -k (или --dmesg)</a>._

Что это? Команда для просмотра логов ядра через систему journald (часть systemd).

Источник данных: Читает те же данные, что и dmesg, но из журнала systemd.

**Особенности:**

- Показывает сообщения также с момента последней загрузки по умолчанию.
- Главное преимущество: journald может вести постоянную запись, поэтому с помощью journalctl можно посмотреть логи ядра и за предыдущие сеансы (после перезагрузки), если эта функция настроена.
- Имеет более мощные фильтры (по времени, юниту, приоритету).
- Временные метки обычно уже в удобном формате.

**Использование:** `journalctl -k`, `journalctl -k --since "today"`, `journalctl -k -b -1` (логи ядра с предыдущей загрузки)




:white_check_mark: _**Задача:** <a name='1'>/var/log/kern.log</a>._

Что это? Традиционный текстовый файл, в который демон rsyslog или syslog-ng записывает сообщения, поступающие от ядра (и других источников, помеченных для этого файла).

Источник данных: Демон syslog читает сообщения из того же буфера ядра, что и dmesg, и записывает их в файл согласно своим правилам конфигурации (/etc/rsyslog.conf, /etc/rsyslog.d/50-default.conf).

**Особенности:**

- Это постоянное хранилище. Логи сохраняются после перезагрузки и ротируются (сжимаются, старые удаляются).
- Позволяет легко применять стандартные текстовые утилиты (grep, awk, tail -f).
- Его содержимое может быть подмножеством вывода dmesg, так как syslog может фильтровать и сортировать сообщения по разным файлам (например, auth.log, syslog).

**Использование:** `tail -f /var/log/kern.log`, `grep -i "oom" /var/log/kern.log`




### Практический вывод и что использовать:

**1. Самые свежие сообщения (только что случившаяся ошибка):**

- `sudo dmesg -T -w` (будет показывать новые сообщения в реальном времени)
- `sudo journalctl -k -f` (аналогично, в режиме follow)

**2. Анализ недавней проблемы (после перезагрузки):**

- `sudo journalctl -k --since "2024-01-15 10:00:00" --until "2024-01-15 11:00:00"`
- `sudo grep "Out of memory" /var/log/kern.log` (идеально для поиска OOM Killer, как в вашем случае)

**3. Анализ проблемы, которая была давно:**

- `sudo zgrep "Out of memory" /var/log/kern.log.1` (просмотр прошлого файла лога)
- `sudo zgrep "Out of memory" /var/log/kern.log.2.gz` (просмотр сжатых архивов)
- `sudo journalctl -k -b -1` (просмотр логов ядра с предыдущей загрузки, если поддерживается)

**Итог:** Для вашего конкретного случая с OOM Killer сообщения будут абсолютно одинаковыми во всех трех источниках, так как они все берут данные из одного корня — буфера сообщений ядра. Разница лишь в том, как эти данные хранятся и предоставляются вам.



















