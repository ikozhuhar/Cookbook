## Управление файлами и  каталогами


[Создание файлов и каталогов](#1)  
[Удаление файлов и каталогов](#2)  
[Копирование, перемещение и переименование файлов и каталогов](#3)  
[Настройка разрешений с помощью chmod](#4)  
[Особые режимы для особых случаев использования - sTicky](#5)  
[chown - сменить владельца файла или каталога](#6)  
[Настройка разрешений по умолчанию с помощью команды umask](#7)  
[Создание символических и жестких ссылок на файлы и каталоги](#8)  


<br>

_**<a name='1'>Задача</a>**: Создание файлов и каталогов._

```ruby
# Cоздаст новый подкаталог в текущем каталоге
 mkdir -v presentations
 
 # Создать двухуровневое дерево каталогов
 mkdir -p presentations/2020/august

# Одновременно с созданием каталога можно задать разрешения
mkdir -m 0700 /home/duchess/dog-memes
```

Посмотореть дерево каталогов

```ruby
# Посмтореть дерево каталогов
tree -L 1 /
tree -L 2 /home
```

Создание файлов

```ruby
# Следующая команда создаст один пустой файл
touch newfile.txt

# А так можно создать 100 новых пустых файлов
touch file{00..99}
touch test{00..99}.doc

# Cоздать непустой файл размером 500 Мбайт, заполненный повторяющейся строкой This is a test file с помощью команды yes
yes This is a test file | head -c 500 MB > testfile.txt

# Cоздание 100 файлов, каждый размером 1 Мбайт
$ for x in {01..100};
> do yes This is a test file | head -c 1MB > $x-testfile.txt;
> done
```


<br>

_**<a name='2'>Задача</a>**: Удаление файлов и каталогов._

```ruby
# Удаление единственного файла с подробным отчетом
rm -v aria.ogg

# Флаг -i потребует подтвердить решение перед удалением
rm -iv intermezzo.wav

# Флаг -r (recursive — «рекурсивно»), чтобы удалить каталог и все файлы
# и каталоги, содержащиеся в нем
rm -rvi rehearsals

# Удалить все файлы с определенным расширением
rm -v *.txt

# Удалить все файлы с определенной последовательности символов
rm -v aria*

# Если rm отказывается удалить файл или каталог и вы уверены, что хотите его
# удалить, то добавьте параметр -f (force — «принудительно»).
```


<br>

_**<a name='3'>Задача</a>**: Копирование, перемещение и переименование файлов и каталогов._

```ruby
# Копирования двух файлов из текущего рабочего каталога в каталог ~/songs2:
cp -v aria.ogg solo.flac ~/songs2/


# Копирование каталога со всем содержимым
cp -rv ~/music/songs2 /shared/archives

# Этот рекурсивный пример просто скопирует каталог songs2 с файлами. Если
# добавить параметр --parents, то команда сохранит структуру родительских
# каталогов.
cp -rv --parents duchess/music/songs2/ shows/

`-a, --archive` — сохраняет все атрибуты файлов, такие как разрешения, владение и отметки времени;
`-i, --interactive` — запрашивает подтверждение, если копирование приведет к затиранию существующих файлов;
`-u, --update` — затирает существующие файлы, только если копируемый файл более новый. Этот параметр поможет сэкономить время, когда требуется повторно скопировать пакет файлов, часть из которых неизменилась (rsync справляется с этой задачей эффективнее, копируя только изменения).
```

Команда `mv` перемещает и переименовывает файлы

```ruby
# Перемещения двух файлов в другой каталог
mv -v aria.ogg solo.flac ~/songs2/

# А эта команда переместит каталог в другой каталог
mv -v ~/songs2/ ~/music/

`-i, --interactive` — запрашивает подтверждение, если перемещение приведет к затиранию существующих файлов;
`-n, --no-clobber` — предотвращает затирание существующих файлов;
`-u, --update` — перемещает файлы, только если они более новые, чем файлы в каталоге назначения, или если они перемещаются впервые.
```

_**<a name='4'>Задача</a>**: Настройка разрешений с помощью chmod._

```ruby
# разрешения для файлов
chmod -v 0600 file.txt
chmod -v 444 file1 file2 file3
chmod -v 644 *.txt
chmod -v 644 abcd*

# чтение/запись владельцу и только чтения группе и всем остальным
chmod -v 0644 file.txt

# права на чтение и запись владельцу и группе, и запрет на все всем остальным
chmod 0660 file.txt

chmod 0750 backup.sh

# все файлы в текущем каталоге
find /home -type f -exec chmod -v 660 {} \;
find /home -user madmax -exec chmod -v 660 {} \;
find /home -user 1007 -exec chmod -v 660 {} \;
```
_Точка (`find .`) сообщает команде `find`, что она должна начать поиск с текущего каталога. При необходимости поиск можно начать с любого каталога._

_`-type f` требует выполнять поиск только среди файлов._

_`-user` проверяет принадлежность файлов указанному пользователю._

_`-exec chmod -v 660 {} \;` — это чудесное маленькое заклинание, которое берет результаты поиска и применяет к ним команду `chmod -v 660`. В этом месте можно использовать практически любую команду, какую вы решите применить к результатам поиска._


Настройка разрешений для каталогов

```ruby
# Следующая команда создаст каталог shared
sudo mkdir /shared

Чтение/запись владельцу /shared и только чтение всем остальным
chmod 0755 /shared

# Владелец имеет неограниченные права доступа к каталогу. Группа и все остальные (мир) смогут входить 
# в каталог и читать файлы, но не смогут их редактировать или добавлять.
chmod 0755 /shared

# Следующая команда применит одни и те же разрешения к существующему содержимому 
# каталога благодаря параметру -R (recursive — «рекурсивно»):
chmod -R 0755 /shared
```

<a name='5'>Особые</a> режимы для особых случаев использования

Задействуйте особые режимы `sticky bit`, `setuid` и `setgid`. Режим `sticky bit` применяется к каталогам с файлами, принадлежащими разным пользователям, чтобы не позволить пользователям перемещать, переименовывать или удалять файлы, которыми они не владеют.

Режим `sticky bit` (бит закрепления, или «липкий» бит) имеет описательное название: **бит ограничения возможности удаления**. Этот бит запрещает непривилегированным пользователям удалять или переименовывать файл в каталоге, если он не принадлежит им, например, в каталоге `/tmp`.

```ruby
# sticky bit - t, sTicky «липучка», атрибут ограниченного удаления
chmod -v 1770 /home/duchess/shared
chmod o+t /shared/stickydir
```
![image](https://github.com/user-attachments/assets/10246e5d-9b86-4afd-b76d-180844d3c6ea)


Режим `setuid` применяется к выполняемым файлам, чтобы повысить привилегии пользователя, запускающего этот файл, до уровня привилегий владельца файла:

```ruby
# setuid - s, Set user/group ID атрибут неявного делегирования полномочий
chmod 4750 backup-script
chmod -v u+s backup-script
```

Режим `setgid` применяется к каталогам и выполняемым файлам: все вновь создаваемые файлы в каталоге будут принадлежать к той же группе, что и сам он. Это отличный прием, позволяющий определить верные уровни владения файлами в общем каталоге:

```ruby
# setgid - s, Set user/group ID атрибут неявного делегирования полномочий
chmod 2770 /home/duchess/shared
chmod -v g+s /shared
```

Режим `setgid` также может применяться к выполняемым файлам, чтобы изменить эффективную группу на группу, владеющую файлом.

Удаление особых режимов разрешений для файла или каталога.

```ruby
# Удаление особых режимов несколько отличается от их установки, поскольку при этом требуется использовать
# дополнительный ведущий ноль, как в следующем примере:

# Ведущий ноль для удаление особых режимов
$ chmod -v 00770 backup.sh

# Ведущий ноль можно заменить знаком равенства:
$ chmod -v =770 backup.sh
```

```ruby
# Linux книга рецептов. Карла Шрёдер, стр. 188
# Внутренее устройство Linux. Дмитрий Кетов, стр. 95
```


<br>

_**<a name='6'>Задача</a>**: chown - сменить владельца файла или каталога._

```ruby
# Сменить владельца и группы
sudo chown -v madmax:madmax song.wav

# Смена только владельца
sudo chown -v madmax: song.wav

# Смена только группы
sudo chown -v :madmax song.wav

# Сменить владельца и группы для нескольких файлов
sudo chown -v madmax:share file1 file2 file3

# Смена владельца/группы для файлов с опр расширением
sudo chown -v madmax:share *.txt

# Смена владельца для ВСЕХ файлов в каталоге
sudo find / -user duchess -exec chown -v stash {} \;
sudo find / -user 1001 -exec chown -v 1005 {} \;
```



<br>

_**<a name='7'>Задача</a>**: Настройка разрешений по умолчанию с помощью команды umask._

Разрешения по умолчанию определяются маской umask (`user file-creation mode mask` — «маска режимов по умолчанию для файлов, вновь создаваемых пользователем»). Узнать текущее состояние маски можно с помощью одноименной команды:

```ruby
umask
umask -S
```

Она устанавливает набор разрешений по умолчанию `0775` для каталогов и `0664` для файлов, то есть umask «маскирует» жестко заданные разрешения по умолчанию `0777` и `0666`. Операцию маскировки можно также представить как операцию вычитания (удаления разрешения), `0777` – `0002` = `0775`.

```ruby
# Временное изменение маски до конца текщего сеанса
umask 0022
```

Чтобы новая маска использовалась постоянно, вставьте команду `umask 0022` в свой файл `~/.bashrc`.

Маска по умолчанию для всех пользователей в системе назначается в файле `/etc/login.defs`



<br>

_**<a name='8'>Задача</a>**: Создание символических и жестких ссылок на файлы и каталоги._

В Linux есть два типа ссылок: символические и жесткие. Символические ссылки могут ссылаться на файлы и каталоги, а жесткие — только на файлы.

Ссылки обоих типов создаются командой `ln` (link — «ссылка»). Следующая команда создаст в текущем каталоге символическую ссылку на внешний каталог `/files/userstuff`:

```ruby
# Здесь /files/userstuff — это цель, а stuff — имя символической ссылки.
ln -s /files/userstuff stuff
```

Здесь `/files/userstuff` — это цель, а `stuff` — имя символической ссылки. Вы можете давать своим ссылкам любые имена, перемещать и удалять их, не оказывая влияния на их цели.

Жесткие ссылки — это копии файлов. По умолчанию команда `ln` создает жесткие ссылки:

```ruby
$ ln /files/config1.txt myconf.txt
```

**Важно:** Символические ссылки могут ссылаться на файлы и каталоги, а жесткие ссылки — только на файлы.


<br>

**Символические ссылки**

Символические ссылки ссылаются на файлы и каталоги. Когда цель символической ссылки удаляется, переименовывается или перемещается, символическая ссылка перестает работать. В случае создания нового файла с тем же именем, что и у удаленного файла, символическая ссылка восстановит работоспособность, даже если содержимое файла будет другим.

Символические ссылки могут пересекать границы файловых систем. Вы можете даже создавать символические ссылки на файлы или каталоги, недоступные постоянно, например находящиеся на USB-накопителе или на сетевом файловом ресурсе.

Разрешения или владельца символической ссылки нельзя изменить, поскольку они зависят от разрешений целевого объекта.

Символическая ссылка выглядит следующим образом:

```ruby
# Создание ссылки
ln -s Switching-and-Routing-09.02.2025.mm link_name
```

![image](https://github.com/user-attachments/assets/fe27acb4-0aae-489e-98ef-15eddd63feb5)

![image](https://github.com/user-attachments/assets/5e2cc86e-0874-40e5-b38a-a0abd28ffea1)

_Краткое содержание_

1. Ссылаются на файлы и каталоги.
2. При удалении, перемещение, переименовании цели ссылка перестает работать.
3. Могут пересекать границы файловых систем.
4. Можно создавать ссылки на файлы или каталоги на USB-накопителе или shared-папки.
5. Разрешения или владельца ссылки изменить нельзя, они зависят от разрешений цели.



<br>

**Жесткие ссылки**

Каждый файл уникально идентифицируется индексным узлом (`inode`), а индексный узел — это то, на что ссылается жесткая ссылка, то есть жесткая ссылка ссылается не на имя файла, а на индексный узел. В следующем примере индексный узел имеет номер `9569138`, и тот же номер используется в трех жестких ссылках. То есть все три индексных узла указывают на один и тот же блок данных.

![image](https://github.com/user-attachments/assets/16137789-a977-4e1e-9688-656d337102f7)

![image](https://github.com/user-attachments/assets/a7ee07ff-e7ef-4edb-a63d-0791d2c12a09)

Жесткие ссылки работают всегда, поскольку ссылаются на индексные узлы. Файлы, на которые ссылается несколько жестких ссылок, можно перемещать, переименовывать и редактировать, и все эти операции не будут отражаться на жестких ссылках, поскольку все они ссылаются на один и тот же блок данных.

Жесткие ссылки не могут пересекать границ файловых систем и существуют только в рамках одной файловой системы. Например, если `/` и `/home` находятся в разных дисковых разделах, то вы не сможете создать жесткую ссылку в `/home`, ссылающуюся на файл в `/`.

Можно создать сколько угодно жестких ссылок, указывающих на один и тот же файл, и дисковое пространство, занятое данными, на которые указывают эти ссылки, не изменится.

Файл не удаляется с диска полностью, пока не будут удалены все жесткие ссылки на него. Убедиться в этом можно с помощью команды `ls`. Ниже показано продолжение предыдущего примера с тремя жесткими ссылками:

![image](https://github.com/user-attachments/assets/dbe0fea2-cb69-4640-b5a0-5aeb85565212)

![image](https://github.com/user-attachments/assets/b600f004-ca47-41b9-be3c-87aac67666ed)

Сравните значения полей `File`, `Size` и `Links` со значениями этих же полей в примерах с символическими ссылками. Жесткая ссылка — обычный файл, обратите внимание на поле `Links: 4`. Оно показывает, что в данном случае есть четыре жесткие ссылки, указывающие на одни и те же данные. 

При удалении файла с несколькими жесткими ссылками он не удаляется, пока не будет удалена последняя жесткая ссылка. Ниже показано, как можно найти все связанные жесткие ссылки с помощью команды `find`:

```ruby
sudo find /home -xdev -samefile ./OTUS/script.sh
```

_Краткое содержание_

1. Жесткая ссылка ссылается не на имя файла, а на индексный узел `inode`.
2. Жесткие ссылки работают всегда, поскольку ссылаются на индексные узлы.
3. Можно перемещать, переименовывать и редактировать.
4. Жесткие ссылки не могут пересекать границ файловых систем и существуют в рамках одной файловой системы.
5. Файл не удаляется с диска полностью, пока не будут удалены все жесткие ссылки на него. 

